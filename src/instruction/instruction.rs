use std::collections::HashMap;
use include_dir::{include_dir, Dir};

pub const OUTPUT_MAP_STRING: [&str; 23] = ["PC_OUT", "PC_IN", "PC_INC", "MEM_ADDR_PTR_IN", "ALU_IN_A", "ALU_IN_B", "CAL_REG_A_IN", "CAL_REG_B_IN", "CAL_REG_A_OUT", "CAL_REG_B_OUT", "IMMEDIATE_OUT", "INSTR_IN", "MEM_OUT", "PLUS_OUT", "RESET_MICRO", "STDTRANS_IN", "STDTRANS_OUT", "STDTRANS_SEND", "ZF_IN", "ZF_OUT", "SUB_OUT", "MEM_BYTE_OUT", "LSH_OUT"]; // The left-most string in the list will end up in the LSb of the control 'word'
/// The instruction map generated by 'smiscasm'
const GENERATED_INSTRUCTIONS: Dir = include_dir!("$CARGO_MANIFEST_DIR/instruction-gen");


/// Gets all instructions and creates a hash map with the op-code and the indexes of the micro commands in the OUTPUT_MAP_STRING
pub fn get_generated_instructions() -> HashMap<u16, Vec<u8>> {
    let mut instructions: HashMap<u16, Vec<u8>> = HashMap::new();

    // Gather all instruction tables
    let mut instruction_tables: Vec<Vec<u8>> = Vec::new();

    for i in 1..=8{
        let mut file_name = format!("smiscasm_instructions-{}", i);

        match i {
            1 => { file_name = file_name + "-MSB.o"}
            8 => { file_name = file_name + "-LSB.o"; }
            _ => { file_name = file_name + ".o"}
        }

        let contents = GENERATED_INSTRUCTIONS.get_file(file_name).unwrap().contents().to_vec();

        instruction_tables.push(contents);
    }

    // Generate one big beautiful instruction table from those tables
    let mut instruction_table: Vec<u64> = Vec::new();

    for i in 0x0..=0xFF_FF {
        // Little endian array of the control bytes for this op-code (i)
        let mut micro_ops_for_i: Vec<u8> = Vec::new();

        for j in 0..8{
            micro_ops_for_i.push(instruction_tables[j][i]);
        }

        micro_ops_for_i.reverse();

        // Concat this array to an u64
        let mut big_beautiful_op_code = 0u64;

        for i in micro_ops_for_i.iter().enumerate() {
            let byte = i.1.clone();
            let i = i.0.clone();

            big_beautiful_op_code |= (byte as u64) << (i * 8);
        }

        instruction_table.push(big_beautiful_op_code);
    }

    // Go through all the possible instruction op-codes and get the indexes with a '1'
    for i in 0x0..=0xFF_FF {
        let mut indexes: Vec<u8> = Vec::new();

        for j in 0..64{
            let idx_has_one = instruction_table[i].clone() & (0x1 << j) > 0;

            if idx_has_one {
                indexes.push(j as u8);
            }
        }

        instructions.insert(i as u16, indexes);
    }

    instructions
}


#[cfg(test)]
mod tests {
    use crate::instruction::instruction::get_generated_instructions;

    #[test]
    fn test_get_generated_instructions() {
        // Generate the instructions
        let instr_gen = get_generated_instructions();

        // Since writing tests for this takes a long time & I'm lazy,
        // only the add_r instruction's third state will be tested (without any flags set)

        let op_code = 0x14_23u16;

        let control_word_indexes = instr_gen.get(&op_code).unwrap().clone();

        let expected_control_word_indexes: Vec<u8> = vec![4, 9];

        assert_eq!(control_word_indexes, expected_control_word_indexes);
    }
}